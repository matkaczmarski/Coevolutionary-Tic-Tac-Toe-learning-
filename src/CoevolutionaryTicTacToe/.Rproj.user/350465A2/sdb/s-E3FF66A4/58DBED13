{
    "contents" : "startLearning <- function(N, K, nrOfIndividuals, learningTime){\n  if (nrOfIndividuals %% 4 != 0){\n    print(\"Liczba osobników w populacji musi być podzielna przez 4\")\n    return(NULL)\n  }\n  \n  m = 1000\n  \n  population_1 = matrix(0, nrOfIndividuals, 3^(N*N))\n  population_2 = matrix(0, nrOfIndividuals, 3^(N*N))\n  \n  for (i in 1:nrOfIndividuals){\n    population_1[i,] = generateIndividual(N)\n    population_2[i,] = generateIndividual(N)\n  }\n  \n  for (t in 1:learningTime){\n    scores_1 = matrix(0, nrOfIndividuals, 1)\n    scores_2 = matrix(0, nrOfIndividuals, 1)\n    \n    for (k in 1:nrOfIndividuals){\n      for (k2 in 1:nrOfIndividuals){\n        scores = battle(N, K, population_1[k,], population_2[k2,])\n        scores_1[k] = scores_1[k] + scores[1]\n        scores_2[k2] = scores_2[k2] + scores[2]\n      }\n    }\n    \n    best_1_index = sort(scores_1, decreasing = TRUE, index.return = TRUE)[2]\n    best_2_index = sort(scores_2, decreasing = TRUE, index.return = TRUE)[2]\n    \n    best_1 = matrix(0, nrOfIndividuals, 3^(N*N))\n    best_2 = matrix(0, nrOfIndividuals, 3^(N*N))\n    \n    if (t == learningTime){\n      bestIndividuals = matrix(0, 2, 3^(N*N))\n      bestIndividuals[1,] = population_1[best_1_index[[1]][1],]\n      bestIndividuals[2,] = population_2[best_2_index[[1]][1],]\n      \n      return(bestIndividuals)\n    }\n    \n    for (i in 1:(floor(nrOfIndividuals / 4))){\n      best_1[i * 4 - 3,] = population_1[best_1_index[[1]][i * 2 - 1],]\n      best_1[i * 4 - 2,] = population_1[best_1_index[[1]][i * 2],]\n      children = crossover(population_1[best_1_index[[1]][i * 2 - 1],], population_1[best_1_index[[1]][i * 2],], m)\n      best_1[i * 4 - 1,] = children[1]\n      best_1[i * 4,] = children[2]\n      \n      best_2[i * 4 - 3,] = population_2[best_2_index[[1]][i * 2 - 1],]\n      best_2[i * 4 - 2,] = population_2[best_2_index[[1]][i * 2],]\n      children = crossover(population_2[best_2_index[[1]][i * 2 - 1],], population_2[best_2_index[[1]][i * 2],], m)\n      best_2[i * 4 - 1,] = children[1]\n      best_2[i * 4,] = children[2]\n    }\n  }\n  \n  return(NULL)\n}\n\n# Algorytm krzyzowania\ncrossover <- function(a,b,m){\n  if(length(a) != length(b) || m < 1){\n    return(FALSE)\n  }\n  divisions = c(1,sort(sample(2:(length(a)-1),m,replace=F)), length(a))\n  children = matrix(0, 2, length(a));\n  \n  for(i in 1:(length(divisions)-1)){\n    if(i%%2 == 0){\n      children[1,divisions[i]:divisions[i+1]] = a[divisions[i]:divisions[i+1]]\n      children[2,divisions[i]:divisions[i+1]] = b[divisions[i]:divisions[i+1]]\n    }\n    else{\n      children[1,divisions[i]:divisions[i+1]] = b[divisions[i]:divisions[i+1]]\n      children[2,divisions[i]:divisions[i+1]] = a[divisions[i]:divisions[i+1]]\n    }\n  }\n  return(children)\n}\n\nisIndexValid <- function(board,x,y){\n  return(x > 0 && y > 0 && x <= nrow(board) && y <= ncol(board))\n}\n\ncheckResult <- function(board, x,y,character, K){\n  hStart <- y\n  hEnd <- y\n  #horizontal\n  for(i in 1:K){\n    if(isIndexValid(board,x, y - i) && board[x,y-i] == character){\n      hStart <- (y-i)\n    }\n    else{\n      break\n    }\n  }\n  for(i in 1:K){\n    if(isIndexValid(board,x, y + i) && board[x,y+i] == character){\n      hEnd <- (y+i)\n    }\n    else{\n      break\n    }\n  }\n  if(hEnd - hStart + 1 >= K){\n    return(TRUE)\n  }\n  \n  vStart <- x\n  vEnd <- x\n  #vertical\n  for(i in 1:K){\n    if(isIndexValid(board,x-i, y) && board[x-i,y] == character){\n      vStart <- (x-i)\n    }\n    else{\n      break\n    }\n  }\n  for(i in 1:K){\n    if(isIndexValid(board,x+i, y) && board[x+i,y] == character){\n      vEnd <- (x+i)\n    }\n    else{\n      break\n    }\n  }\n  if(vEnd - vStart + 1 >= K){\n    return(TRUE)\n  }\n  \n  dStart <- 0\n  dEnd <- 0\n  #diagonal\n  for(i in 1:K){\n    if(isIndexValid(board,x-i, y-i) && board[x-i,y-i] == character){\n      dStart <- i\n    }\n    else{\n      break\n    }\n  }\n  for(i in 1:K){\n    if(isIndexValid(board,x+i, y+i) && board[x+i,y+i] == character){\n      dEnd <- i\n    }\n    else{\n      break\n    }\n  }\n  if(dEnd + dStart + 1 >= K){\n    return(TRUE)\n  }\n  \n  adStart <- 0\n  adEnd <- 0\n  #anti-diagonal\n  for(i in 1:K){\n    if(isIndexValid(board,x+i, y-i) && board[x+i,y-i] == character){\n      adStart <- i\n    }\n    else{\n      break\n    }\n  }\n  for(i in 1:K){\n    if(isIndexValid(board,x-i, y+i) && board[x-i,y+i] == character){\n      adEnd <- i\n    }\n    else{\n      break\n    }\n  }\n  if(adEnd + adStart + 1 >= K){\n    return(TRUE)\n  }\n  \n  return(FALSE)\n}\n\ngetIndecies <- function(fieldId, N){\n  row=0\n  col=0\n  row = fieldId %% N \n  if(row==0){\n    row = N\n    col = fieldId/N\n  }\n  else{\n    col = ceiling(fieldId/N)\n  }\n  return(c(row,col))\n}\n\nbattle <- function(N, K, p1_Strategy, p2_Strategy){\n  p1 = 1\n  p2 = 2\n  scores=c(0,0)\n  \n    board = matrix(0,N,N)\n    moveCounter = N*N\n    \n    while(moveCounter > 0){\n      \n      #p1:\n      randomMove = p1_Strategy[boardToId(board)]#getNextMove(board)\n      board[randomMove] = p1\n      ind = getIndecies(randomMove,N)\n      \n      if(checkResult(board,ind[1],ind[2], p1,K) == TRUE){\n        scores[p1] = scores[p1] + 1\n        scores[p2] = scores[p2] - 2\n        break\n      }\n      \n      moveCounter = moveCounter -1\n      if(moveCounter <= 0){\n        break\n      }\n      \n      #p2:\n      randomMove = p2_Strategy[boardToId(board)]#getNextMove(board)\n      board[randomMove] = p2\n      ind = getIndecies(randomMove,N)\n      if(checkResult(board,ind[1],ind[2],p2,K) == TRUE){\n        scores[p1] = scores[p1] - 2\n        scores[p2] = scores[p2] + 1\n        break\n      }\n      \n      moveCounter = moveCounter -1\n    }\n    \n    board = matrix(0,N,N)\n    moveCounter = N*N\n    \n    while(moveCounter > 0){\n      \n      #p2:\n      randomMove = p2_Strategy[boardToId(board)]#getNextMove(board)\n      board[randomMove] = p2\n      ind = getIndecies(randomMove,N)\n      if(checkResult(board,ind[1],ind[2],p2,K) == TRUE){\n        scores[p1] = scores[p1] - 2\n        scores[p2] = scores[p2] + 1\n        break\n      }\n      \n      moveCounter = moveCounter -1\n      if(moveCounter <= 0){\n        break\n      }\n      \n      #p1:\n      randomMove = p1_Strategy[boardToId(board)]#getNextMove(board)\n      board[randomMove] = p1\n      ind = getIndecies(randomMove,N)\n      \n      if(checkResult(board,ind[1],ind[2], p1,K) == TRUE){\n        scores[p1] = scores[p1] + 1\n        scores[p2] = scores[p2] - 2\n        break\n      }\n      \n      moveCounter = moveCounter -1\n    }\n  \n  return(scores)\n}\n\nboardToId <- function(board){\n  id = 0\n  exponent = 0;\n  for(i in 1:nrow(board)){\n    for(j in 1:ncol(board)){\n      id = (id + board[i,j]*(3^exponent))\n      exponent = exponent + 1\n    }\n  }\n  return(id + 1)\n}\n\nidToBoard <- function(id, dim){\n  board = matrix(0,dim,dim)\n  id = id - 1\n  \n  for(i in 1:nrow(board)){\n    for(j in 1:ncol(board)){\n      board[i,j] = (id %% 3 )\n      id = floor(id/3)\n    }\n  }\n  return(board)\n}\n\ngetNextMove <- function(board){ #(board){\n  possibleMoves = which(board == 0, arr.ind = F)\n  if (length(possibleMoves) == 0)\n    return(0)\n  return(sample(which(board == 0, arr.ind = F),1))\n}\n\ngenerateIndividual <- function(N){\n  dim = 3^(N*N)\n  moves = matrix(0, 1, dim);\n  \n  for (i in 1:ncol(moves)){\n    board = idToBoard(i, N)\n    moves[1, i] = getNextMove(board)\n  }\n  \n  return(moves)\n}",
    "created" : 1433441825449.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "85|49|179|0|\n",
    "hash" : "2446903866",
    "id" : "58DBED13",
    "lastKnownWriteTime" : 1433450704,
    "path" : "C:/Users/Mateusz/Desktop/repozytoria/Coevolutionary-Tic-Tac-Toe-learning-/src/CoevolutionaryTicTacToe/Learning.R",
    "project_path" : "Learning.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}